from quart import Quart, request, jsonify
import uvicorn
import httpx
from utilities import Status, load_config, row_list_to_dict_list
import json
from quart.wrappers import Response

from db import Database, print_table, get_local_time

class Manager():
    def __init__(self, n_max_threads):
        self.n_threads = 0
        self.n_max_threads = n_max_threads
    
    def is_busy(self):
        return self.n_threads >= self.n_max_threads

    def add_threads(self, n):
        if not self.is_busy() and self.n_threads + n <= self.n_max_threads:
            self.n_threads += n
            return True
        return False
    
    def remove_threads(self, n):
        if self.n_threads - n >= 0:
            self.n_threads -= n
            return True
        return False
    
    def get_free_threads(self):
        return self.n_max_threads - self.n_threads

app = Quart(__name__)
db = manager = config = None

@app.before_serving
async def before_serving():
    global db, manager, config
    db = Database('data.db')
    manager = Manager(3)
    send_queries()

def get_queries(limit):
    queries = db.select(
        table='queries',
        columns=['*'],
        where={'status': Status.PENDING.value[0]},
        order_by='created_at',
        limit=limit
    )
    return queries

def send_queries():
    print("Sending queries...")
    if manager.is_busy():
        return
    free_threads = manager.get_free_threads()
    print(f"Free threads: {free_threads}")
    queries = get_queries(free_threads)
    if queries:
        try:
            manager.add_threads(len(queries))
            with httpx.Client(verify=False) as client:
                response = client.post(url=config['urls']['ai'], json=row_list_to_dict_list(queries))
                response.raise_for_status()
                return response
        except httpx.RequestError as e:
            return e
        except httpx.HTTPStatusError as e:
            return e

@app.route('/db/insert', methods=['POST'])
async def insert():
    try:
        data = await request.get_json()
        print("Dati ricevuti: ", data)
        ids = []
        for d in data:
            d.update({'status': Status.PENDING.value[0]})
            ids.append(db.insert(table='queries', record=d))
        send_queries()
        return jsonify({'status': 'success', 'ids': ids})
    except Exception as e:
        print(e)
        return jsonify({'status': 'error'})

@app.route('/db/update', methods=['POST'])
async def update():
    try:
        data = await request.get_json()
        for d in data:
            to_set = {'status': Status.COMPLETED.value[0], 'completed_at': get_local_time(), 'answer': d['answer']}
            db.update(table='queries', set=to_set, where={'id': d['id']})
        manager.remove_threads(len(data))
        send_queries()
        return jsonify({'status': 'success'}), 200
    except Exception as e:
        print(e)
        return jsonify({'status': 'error'}), 500

@app.route('/db/select', methods=['GET'])
async def select():
    try:
        queries = db.select(table='queries', columns=['*'])
        return jsonify(row_list_to_dict_list(queries))
    except Exception as e:
        print(e)
        return jsonify([])
    
def id_parser(ids: str):
    #example: 1, 3-8, 10
    ids = ids.split(',')
    id_list = []
    for i in ids:
        if '-' in i:
            start, end = i.split('-')
            id_list.extend(range(int(start), int(end)+1))
        else:
            id_list.append(int(i))
    return id_list
    

@app.route('/db/select/<id>', methods=['GET'])
async def select_id(id):
    try:
        queries = []
        id = id_parser(id)
        if not id:
            return jsonify([{'status': 'Ah si bestia'}])
        for i in id:
            #*codice professiostazionale
            queries.extend(db.select(table='queries', columns=['id','answer','status'], where={'id': i}))
        data = json.dumps(row_list_to_dict_list(queries))
        return Response(data, mimetype='application/json')
    except Exception as e:
        print(e)
        return jsonify([])

if __name__ == '__main__':
    config = load_config('config.yaml')
    uvicorn.run(app, host='0.0.0.0', port=5000, ssl_keyfile=config['paths']['key'], ssl_certfile=config['paths']['cert'])