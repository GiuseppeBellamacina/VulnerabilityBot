from quart import Quart, request, jsonify
import uvicorn
import asyncio
import httpx
from utilities import Status, load_config, row_list_to_dict_list
import json
from quart.wrappers import Response
from dateutil import parser

from db import Database, get_time

app = Quart(__name__)
db = manager = config = None

class Manager():
    def __init__(self, n_max_threads):
        self.n_threads = 0
        self.n_max_threads = n_max_threads
        self.priority = None
    
    def is_busy(self):
        return self.n_threads >= self.n_max_threads

    def add_threads(self, n):
        if not self.is_busy() and self.n_threads + n <= self.n_max_threads:
            self.n_threads += n
            return True
        return False
    
    def remove_threads(self, n):
        if self.n_threads - n >= 0:
            self.n_threads -= n
            return True
        return False
    
    def get_free_threads(self):
        return self.n_max_threads - self.n_threads

    def get_queries(self, limit):
        if self.priority:
            queries = db.select(
                table='queries',
                columns=['*'],
                where={'status': Status.PENDING.value[0], 
                       'analysis_id': self.priority},
                order_by='created_at DESC',
                limit=limit
            )
            if not queries:
                self.priority = None
                return self.get_queries(limit)
        else:
            queries = db.select(
                table='queries',
                columns=['*'],
                where={'status': Status.PENDING.value[0]},
                order_by='created_at DESC',
                limit=limit
            )
        return queries

    async def send_queries(self):
        print("\33[1;34m[Server]\33[0m: Checking for queries")
        if self.is_busy():
            print("\33[1;34m[Server]\33[0m: Server is busy")
            return
        free_threads = self.get_free_threads()
        print("\33[1;34m[Server]\33[0m: Free threads: ", free_threads)
        queries = self.get_queries(free_threads)
        if queries:
            try:
                print("\33[1;34m[Server]\33[0m: Sending queries")
                self.add_threads(len(queries))
                async with httpx.AsyncClient(verify=False) as client:
                    response = await client.post(url=config['urls']['ai'], json=row_list_to_dict_list(queries))
                    response.raise_for_status()
                    free_threads = self.get_free_threads()
                    print("\33[1;34m[Server]\33[0m: Free threads: ", free_threads)
                    return response
            except httpx.RequestError as e:
                return e
            except httpx.HTTPStatusError as e:
                return e
        else:
            print("\33[1;34m[Server]\33[0m: No queries to send")
    
    def set_priority(self, priority):
        queries = db.select(table="queries",
                            columns=["analysis_id"], 
                            where={"status": Status.PENDING.value[0],
                                   "analysis_id": priority})
        if queries:
            self.priority = priority
            return True
        
@app.route('/db/insert', methods=['POST'])
async def insert():
    try:
        data = await request.get_json()
        print("\33[1;34m[Server]\33[0m: Received", len(data), "queries")
        ids = []
        for d in data:
            d.update({'status': Status.PENDING.value[0]})
            ids.append(db.insert(table='queries', record=d))
        asyncio.run(manager.send_queries())
        return jsonify({'status': 'success', 'ids': ids})
    except Exception as e:
        print(e)
        return jsonify({'status': 'error'})

@app.route('/db/update', methods=['POST'])
async def update():
    try:
        data = await request.get_json()
        for d in data:
            end = get_time()
            start = db.select(table='queries', columns=['created_at'], where={'id': d['id']})[0]['created_at']
            start = parser.parse(start)
            to_set = {'status': Status.COMPLETED.value[0], 
                      'completed_at': end, 
                      'answer': d['answer'],
                      'execution_time': int((end - start).total_seconds() * 1000)}
            db.update(table='queries', set=to_set, where={'id': d['id']})
        manager.remove_threads(len(data))
        asyncio.run(manager.send_queries())
        return jsonify({'status': 'success'}), 200
    except Exception as e:
        print(e)
        return jsonify({'status': 'error'}), 500

@app.route('/db/get', methods=['GET'])
async def select():
    try:
        queries = db.select(table='queries', columns=['*'])
        return jsonify(row_list_to_dict_list(queries))
    except Exception as e:
        print(e)
        return jsonify([])
    
def id_parser(ids: str):
    #example: 1, 3-8, 10
    ids = ids.split(',')
    id_list = []
    for i in ids:
        if '-' in i:
            start, end = i.split('-')
            id_list.extend(range(int(start), int(end)+1))
        else:
            id_list.append(int(i))
    return id_list

@app.route('/db/get/<id>', methods=['GET'])
async def select_id(id):
    try:
        queries = []
        id = id_parser(id)
        if not id:
            return jsonify([{'status': 'Ah si bestia'}])
        for i in id:
            #*codice professiostazionale
            queries.extend(db.select(table='queries', columns=['*'], where={'id': i}))
        data = json.dumps(row_list_to_dict_list(queries))
        return Response(data, mimetype='application/json')
    except Exception as e:
        print(e)
        return jsonify([])

@app.route('/db/get_u/<uuid>', methods=['GET'])
async def select_uuid(uuid):
    try:
        queries = []
        if not uuid:
            return jsonify([{'status': 'Ah si bestia'}])
        #*codice professiostazionale
        manager.set_priority(uuid)
        queries.extend(db.select(table='queries',
                                 columns=['*'],
                                 where={'analysis_id': uuid}))
        data = json.dumps(row_list_to_dict_list(queries))
        return Response(data, mimetype='application/json')
    except Exception as e:
        print(e)
        return jsonify([])

if __name__ == '__main__':
    config = load_config('config.yaml')
    db = Database('data.db')
    manager = Manager(config['n_threads'])
    asyncio.run(manager.send_queries())
    uvicorn.run(app, host='0.0.0.0', port=5000, ssl_keyfile=config['paths']['key'], ssl_certfile=config['paths']['cert'])