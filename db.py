import sqlite3
from os import remove
from datetime import datetime
import pytz

def get_local_time():
    local_tz = pytz.timezone('Europe/Rome')
    return datetime.now(local_tz).strftime('%Y-%m-%d %H:%M:%S')

def print_row(row):
    for key in row.keys():
        print(f'{key}: {row[key]}')
    print()

def print_table(table):
    for row in table:
        print_row(row)

class Database():
    def __init__(self, db_path: str, schema_path='schema.sql'):
        self.db_path = db_path
        self.schema_path = schema_path
        self.create_db()
        print("\33[1;32m[DB]\33[0m: Database created successfully")
    
    def create_db(self):
        with self.get_db_connection() as conn:
            with open(self.schema_path) as f:
                conn.executescript(f.read())
    
    def get_db_connection(self):
        conn = sqlite3.connect(self.db_path)
        conn.row_factory = sqlite3.Row
        return conn
    
    def delete_db(self):
        remove(self.db_path)
    
    def insert(self, table: str, record: dict):
        local_time = get_local_time()
        columns = ', '.join(record.keys()) + ', created_at'
        placeholders = ', '.join('?' * (len(record)+1))
        values = tuple(record.values()) + (local_time,)
        query = f'INSERT INTO {table} ({columns}) VALUES ({placeholders})'
        with self.get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, values)
            conn.commit()
            cursor.close()
        return cursor.lastrowid
    
    def select(self, table: str, columns: list, where: dict = None, order_by: str = None, limit: int = None):
        query = f'SELECT {", ".join(columns)} FROM {table}'
        if where:
            query += ' WHERE ' + ' AND '.join([f'{k}=?' for k in where.keys()])
        if order_by:
            query += f' ORDER BY {order_by}'
        if limit:
            query += f' LIMIT {limit}'
        with self.get_db_connection() as conn:
            cursor = conn.cursor()
            if where:
                cursor.execute(query, tuple(where.values()))
            else:
                cursor.execute(query)
            result = cursor.fetchall()
            cursor.close()
        return result
    
    def update(self, table: str, set: dict, where: dict = None):
        query = f'UPDATE {table} SET {", ".join([f"{k}=?" for k in set.keys()])}'
        values = tuple(set.values())
        if where:
            query += ' WHERE ' + ' AND '.join([f'{k}=?' for k in where.keys()])
            values += tuple(where.values())
        with self.get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, values)
            conn.commit()
            cursor.close()
    
    def delete(self, table: str, where: dict):
        query = f'DELETE FROM {table}'
        if where:
            query += ' WHERE ' + ' AND '.join([f'{k}=?' for k in where.keys()])
        with self.get_db_connection() as conn:
            cursor = conn.cursor()
            cursor.execute(query, tuple(where.values()))
            conn.commit()
            cursor.close()
